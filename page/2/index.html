<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.115.4"><title>Gunnar Þór Magnússon</title><link rel=canonical href=https://www.magnusson.io/><link rel=alternate type=application/rss+xml href=https://www.magnusson.io/index.xml title="Gunnar Þór Magnússon"><link rel=stylesheet href=https://www.magnusson.io/css/base.min.c8d7b76018962ae348ca009f0c82f2ed51a7ad01f94e2091060a820b89493837.css integrity="sha256-yNe3YBiWKuNIygCfDILy7VGnrQH5TiCRBgqCC4lJODc=" crossorigin=anonymous></head><body><nav class=u-background><div class=u-wrapper><ul class=Banner><li class="Banner-item Banner-item--title"><a class="Banner-link u-clickable" href=https://www.magnusson.io/>Gunnar Þór Magnússon</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=https://www.magnusson.io/about/>About</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=https://www.magnusson.io/post/>Posts</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=https://www.magnusson.io/index.xml>RSS</a></li></ul></div></nav><main><div class=u-wrapper><div class=u-padding><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/kleroteria/ rel=bookmark>Kleroteria</a></h2><time datetime=2020-04-15T08:51:31+02:00>15 April, 2020</time></header><div class=paragraph><p>I got picked in
<a href=https://www.kleroteria.org/>Kleroteria</a>
a couple of months ago. This is my contribution.</p></div><hr><div class=paragraph><p>Three years ago, my wife and I moved to Amsterdam. We wanted to have kids, and
thought the Netherlands was a better place to do that than Mexico, where my wife
is from and we lived.</p></div><div class=paragraph><p>We’ve both moved around a lot, and have picked up the languages of the places
we’ve lived. That’s how we speak French and Spanish, along with English.
Learning those was always a necessity; no one in France is going to speak
English voluntarily, and my in-laws don’t speak the best English so I had to
learn Spanish.</p></div><div class=paragraph><p>So it was a change to come to the Netherlands. Everyone here speaks perfect
English. They also have no patience for your attempts at Dutch pronunciation or
verb conjugation. The second they hear you’re not from here, they switch. On
paper this is great, but it means that after three years here I still don’t
speak Dutch. I can never get anyone to have a whole conversation with me in it.</p></div><div class=paragraph><p>A couple of weeks after we came here, we got pregnant. We had a boy, who has
grown up into a little man who loves cars and trains, makes funny faces at the
dinner table, and keeps trying to show our dog his books. ("Pancho! See!", but
Pancho doesn’t care.)</p></div><div class=paragraph><p>We speak to him each in our own language, and by now he understands what we say.
He’s been going to daycare here since he was five months old, where they speak
Dutch, so he understands that as well. Kids who grow up with more than one
language start speaking later, which is can be frustrating for everyone. He
knows what he wants to say, but can’t figure out what words to use, and we have
to keep guessing at sounds while other parents don’t.</p></div><div class=paragraph><p>He’s finally speaking now. He tells us everything he wants and knows. In Dutch.
Every time. Every word comes out in Dutch. And we still don’t really speak it.
It’s not really any less frustrating for anyone. There’s a lot of guessing at
pronunciation and Google translate.</p></div><div class=paragraph><p>But what do you know. I did finally get someone to speak Dutch to me.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/bug-checklist/ rel=bookmark>Bug-fixing checklist</a></h2><time datetime=2020-04-15T07:04:37+02:00>15 April, 2020</time></header><div class=paragraph><p>It is OK not to do all of these things for a given bug. Some bugs are trivial,
or nontrivial to reproduce or write tests for. But you should explicitly decide
not to do some of these things for any given bug, and be able to explain why.</p></div><div class="olist arabic"><ol class=arabic><li><p>Is there a (possibly old, closed) issue for the bug?</p></li><li><p>Can you reproduce the bug manually?</p></li><li><p>Can you write a regression test for the bug?</p></li><li><p>Did you check that your change actually fixes the problem?</p></li><li><p>Does the fix’s commit message explain the bug, the fix, and point to the issue?</p></li></ol></div><div class=paragraph><p>It’s debatable whether checking for old or closed issues is the responsibility
of the developer fixing the bug or a project manager who triages the backlog.
Sometimes the second person doesn’t exist, but the job should still be done.</p></div><div class=paragraph><p>Remember that a bug report is a report of a symptom. A bug fix is directed at
a cause. A software symptom may have more than one cause, making bug fixes that
say "This fixes issue X" very optimistic about what they claim to achieve.</p></div><div class=paragraph><p>Exercise moderation and common sense in all things. Both 0% and 100% test
coverage are awkward places to live in. Sometimes the information or effort
needed to write a test make it too expensive to do so. However, when writing a
test is cheap and easy or can be made so without causing harm, there should be
a good reason not to do it.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/gitsplorer/ rel=bookmark>Gitsplorer</a></h2><time datetime=2019-10-20T16:49:02+02:00>20 October, 2019</time></header><div class=paragraph><p>Have you ever found yourself using Git and thinking "This is great, but I wish
these filesystem operations were read-only and ten times slower?". Well, friend,
do I have news for you.</p></div><div class=paragraph><p>API of a Golang codebase at different times in its history. To do this, I
figured I’d clone the repo, check out commit A and analyze it, then check out
commit B and analyze that, and boo! Hiss! That’s inelegant and leaves clutter
that needs to be cleaned up all around the disk. There has got to be a better
way!</p></div><div class=paragraph><p>Once I made a <a href=https://github.com/gunnihinn/git-commit-mine>Git commit hash
miner</a> because I wanted to race it against a coworker to see who could get a
commit with more leading zeros into a frequently used repository at work. That
had the side effect of teaching me some about Git’s internals, like what its
objects are (blobs, trees, commits, tags) and how they fit together. I figured
that if I could convince the Golang AST parser to read the Git database instead
of the filesystem, I could do what I wanted in a much better way.</p></div><div class=paragraph><p>Alas, doing that would have required monkey-patching the Go standard library,
and I don’t want to hunt down every system call it ends up making to be sure I
got them all. However, Git is famously a content-addressable filesystem, so what
if we just made a filesystem that points to a given commit in a repo and pointed
the parser at that?</p></div><div class=paragraph><p>This turns out to be pretty easy to do by combining <code>libgit2</code> and <code>libfuse</code>. We
use the former to read objects in the Git repository. (The objects are easy to
read by hand, until you have to read packed objects. That’s doable, but a bit
of a distraction in what is already quite the distraction.) We then use the
latter to create a very basic read-only filesystem. In the end, we have a
read-only version of <code>git checkout</code> that writes nothing to disk.</p></div><div class=paragraph><p>I put a prototype of this together in Python, because I’m lazy. It’s called
<a href=https://github.com/gunnihinn/gitsplorer/><code>gitsplorer</code></a> and you should absolutely
not use it anywhere near a production system. It scratches my itch pretty well,
though. In addition to my API comparisons (which I still haven’t got to), I do
sometimes want to poke around the state of a repository at a given commit and
this saves me doing a stash-checkout dance or reading the <code>git worktree</code> manpage
again.</p></div><div class=paragraph><p>For fun, and to see how bad of an idea this was, I came up with a very
unscientific benchmark: We checkout the Linux kernel repository at a randomly
selected
<a href=https://github.com/torvalds/linux/commit/29c7f1f53bfb3770bdb65a9e79064a963dd40621>commit</a>,
run Boyter’s <a href=https://github.com/boyter/scc>scc</a> line-counting tool, and checkout
<code>master</code> again. We do this both with <code>gitsplorer</code> and with ye olde <code>git
checkout</code>. The results speak for themselves:</p></div><div class=listingblock><div class=content><pre>git checkout: 62 seconds
gitsplorer: 567 seconds</pre></div></div><div class=paragraph><p>The <code>gitsplorer</code> version is also remarkable for spending all its time using 100%
of a CPU, which the <code>git</code> version does not. (It uses around 90% of a CPU while
doing the checkouts, then all of my CPUs while counting lines. The Python FUSE
filesystem is single-threaded, so beyond Python being slow it must also be a
point of congestion for the line counting.) I did some basic profiling of this
with the wonderful profiler <a href=https://github.com/P403n1x87/austin>Austin</a>, and saw
that the Python process spends most of its time reading Git blobs. I think, but
did not verify, that this is because <code>libgit2</code> decompresses the contents of the
blobs on every such call, while most of the reads we make are in the FUSE
<code>getattr</code> call where we are only interested in metadata about the blob. I made
no attempts to optimize any of this.</p></div><div class=paragraph><p>So, friends, if you’ve ever wished <code>git checkout</code> was read-only and 10 times
slower than it is, today is your lucky day.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/lyttle-lytton-2020/ rel=bookmark>Lyttle Lytton 2020</a></h2><time datetime=2019-10-06T11:07:55+02:00>6 October, 2019</time></header><div class=paragraph><p>My <a href=http://adamcadre.ac/lyttle.html>Lyttle Lytton</a> entry for 2020:</p></div><div class=quoteblock><blockquote><div class=paragraph><p>"Actually, you do like this," maverick CEO Eric Davies, Ph.D., insisted as he
pulled my foreskin back and cunnilingussed my pee hole.</p></div></blockquote></div><div class=paragraph><p>I’m not exactly proud of it, but I’m glad it’s no longer in my head.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/not-this-world/ rel=bookmark>Not made for this world</a></h2><time datetime=2019-07-31T07:38:25+02:00>31 July, 2019</time></header><div class=paragraph><p>It’s hot tonight, and this is going to be mostly the whiskey talking while I
wait for it to get cool enough to sleep. I’ve killed the mosquitos I’ve seen,
however, so until then I have only Haskell to keep me company.</p></div><div class=paragraph><p>This morning, tef tweeted about
<a href=https://twitter.com/tef_ebooks/status/1155705690947805184>monads</a>,
which sent the Haskell pack his way with
barks of not getting it. Just now, pinboard was reminded of some guy’s rage
against
<a href=https://twitter.com/Pinboard/status/1156288764345348096>Esperanto</a>,
from back in the 90’s when the web was fun and mostly devoted
to things like explaining how "The Downward Spiral" is a concept album or
destroying Unix instead of each other’s mental health.</p></div><div class=paragraph><p>For the Haskell pack, I did a PhD in the type of math that necessitates a lot of
category theory, and I have looked at your use of category theory, and judged it
to be unnecessary and pretentious and mainly focused on making you look smart
while being entirely trivial. But this is not that kind of blog post, one that
gets too tangled up in whether category theory is useful to get to the point.
(If nothing else,
<a href=https://jneem.github.io/merging/>Pijul</a>
proves that category theory is useful.) We’re here to discuss how Haskell as a
whole is nonsense if you’re not an academic. Our claim is that Haskell is a
useless language for writing software that has users.</p></div><div class=paragraph><p>Our point is simple, and focused on IO. We propose that you can measure how
user-facing a program or language is by measuring how much of its time it spends
or worries about doing IO. That is, after all, the medium through which anyone
who is not a program’s author (of which there may be many) will interact with
the program. The time spent doing IO can be on the command line, via a GUI, over
a network, or wherever; but to be a serious contender for user-facing programs,
a language has to make IO be easy.</p></div><div class=paragraph><p>C is a terrible language for most new things today. Anyone writing new software
in C, that they expect to be used by other than thouroughly vetted people, needs
to be able to explain why they’ve chosen C. At the same time, a lot of us are
still exposed to C through the BSD or Linux kernels and syscalls, the undying
popularity of K&amp;R, random software on the internet, or other vectors. The
culture around C invented the modern language textbook, K&amp;R, and the modern
user-facing program, "Hello world", both of which spend most or all of their
time dealing with IO to talk to you or other users.</p></div><div class=paragraph><p>I claim making IO as simple as possible, which C does for all its faults, to do
is analogous to trying to making it as simple as possible for other people to
talk to you in designed languages as you can.<sup class=footnote>[<a id=_footnoteref_1 class=footnote href=#_footnotedef_1 title="View footnote.">1</a>]</sup>. Esperanto shows you can fail
at that goal, if you even had it, for it favors sounds native to European
languages above others. Likewise, Haskell shows you can fail at the goal of
making IO easy, if you even had it, for it does not.</p></div><div class=paragraph><p>Haskell is a purely functional, lazily evaluated language, with a type system.
Like tef explains, that is great, until you run into IO. Up until that point,
you could rearrange computations in any order you liked, if they needed to be
done at all. As soon as you need to do IO, though, you need something to happen
before another thing, which makes you very unhappy if you’re Haskell. It in fact
makes you so unhappy that you’ll drag the entire lost-at-sea community of
category theorists into the orbit of your language just so you can have an
abstraction for doing IO that fits into your model of the world. This
abstraction, monoids, then comes with the added benefit of being abstract enough
that all of your programmers can spend their time explaining it to each other
instead of writing programs that use the abstraction to do IO, and therefore
deal with any actual users.</p></div><div class=paragraph><p>Haskell is where programmers go to not have users.</p></div><div id=footnotes><hr><div class=footnote id=_footnotedef_1><a href=#_footnoteref_1>1</a>. One could say that what I mean is something more like making FFI as easy as possible, but that’s missing the point and would just move this discussion to some other, less inflammatory, level that we’re keen to avoid.</div></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/curvature/ rel=bookmark>Curvature as a bilinear form</a></h2><time datetime=2019-05-15T07:36:52+02:00>15 May, 2019</time></header><div class=paragraph><p>Here’s something I thought of when I couldn’t sleep last night.</p></div><div class=paragraph><p>The curvature tensor of a Kähler metric can be viewed as a Hermitian form on
\(\bigwedge^{1,1} T_X^*\) by mapping \(\operatorname{End} T_X \to \bigwedge^{1,1}
T_X^*\) via the metric.</p></div><div class=paragraph><p>If we’re on a compact Kähler manifold with zero first Chern class, then for each
Kähler class \(\omega\) and \((1,1)\)-classes \(u, v\), we can pick the Ricci-flat
metric in \(\omega\) and the harmonic representatives of \(u, v\). If \(R\) is the
curvature tensor of the metric, viewed as a Hermitian form, we can then set
\[
b(u,v)(\omega) := \int_X R(u, v) \, dV_{\omega}.
\]
This defines a smooth bilinear form \(b\) on the tangent space of the Kähler cone
of \(X\).</p></div><div class=paragraph><p>Besides being fun times, can we say anything interesting about \(b\)? For example,
what is its norm with respect to the Riemannian metric on the Kähler cone, or
its trace with respect to that metric? Can we integrate it over some subset of
the cone?</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/choices/ rel=bookmark>Choices</a></h2><time datetime=2019-03-09T07:32:23+02:00>9 March, 2019</time></header><div class=paragraph><p>I only have time to work on the arXiv project so often, so I’m taking a lot of
time between sessions to think about what I’m doing. When I look at my system
design notes, I feel like all the decisions I’m making are the obvious choices,
but they also were not at all obvious when I started thinking about them. It’s a
good feeling.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/queuesim/ rel=bookmark>Queuesim</a></h2><time datetime=2019-03-08T07:33:20+02:00>8 March, 2019</time></header><div class=paragraph><p>I haven’t made a lot of progress on my projects. I <em>did</em> create a Scaleway VM
and shoved an OAI harvester on there that’s happily downloading the arXiv’s
backlog of metadata. I can also parse the XML it fetches, and have some ideas
about how I’m going to store it.</p></div><div class=paragraph><p>This lack of progress mostly comes from me being nerd-sniped into thinking
about bounded queues under load. My
<a href=https://github.com/bookingcom/carbonapi/issues/35>old work project</a>
wanted to use a FIFO queue to hold its requests. That is a bad idea, because
FIFO queues perform very poorly under load, as I
<a href=https://github.com/gunnihinn/queuesim>went a little overboard</a>
in demonstrating.</p></div><div class=paragraph><p>Funnily enough, that very simple thing is one of my most popular Github
projects ever.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/ignore-mastodon/ rel=bookmark>Ignore Mastodon</a></h2><time datetime=2019-03-05T07:33:59+02:00>5 March, 2019</time></header><div class=paragraph><p>Point: <a href=https://carlchenet.com/do-not-ignore-the-mastodon-social-network/>You should not ignore the Mastodon social network any more</a>.</p></div><div class=paragraph><p>Counterpoint: I truly, madly, deeply want to ignore all new and existing social
networks.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/shame/ rel=bookmark>Shame</a></h2><time datetime=2019-03-04T07:34:40+02:00>4 March, 2019</time></header><div class=paragraph><p>To motivate me to actually finish some of the projects I start, I’m going to
try announcing them to the world. Shame me into finishing these:</p></div><div class=ulist><ul><li><p>A nicer arXiv frontend of daily new additions.</p></li><li><p>A modern typesetting of Beauville’s <em>Surfaces algebriques complexes</em>.</p></li></ul></div><div class=paragraph><p>Shame. Shame. Shame.</p></div></article><nav><a class="Pagination u-clickable" href=https://www.magnusson.io/page/3/ rel=prev>« Previous</a>
<a class="Pagination Pagination--right u-clickable" href=https://www.magnusson.io/ rel=next>Next »</a></nav></div></div></main><footer class=Footer><div class=u-wrapper><div class=u-padding>Copyright 2018-2020 :: Gunnar Þór Magnússon</div></div><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></footer></body></html>