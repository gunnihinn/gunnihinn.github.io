<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.152.2"><title>Gunnar Þór Magnússon</title><link rel=canonical href=https://www.magnusson.io/><link rel=alternate type=application/rss+xml href=https://www.magnusson.io/index.xml title="Gunnar Þór Magnússon"><link rel=stylesheet href=https://www.magnusson.io/css/base.min.c8d7b76018962ae348ca009f0c82f2ed51a7ad01f94e2091060a820b89493837.css integrity="sha256-yNe3YBiWKuNIygCfDILy7VGnrQH5TiCRBgqCC4lJODc=" crossorigin=anonymous></head><body><nav class=u-background><div class=u-wrapper><ul class=Banner><li class="Banner-item Banner-item--title"><a class="Banner-link u-clickable" href=https://www.magnusson.io/>Gunnar Þór Magnússon</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=https://www.magnusson.io/about/>About</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=https://www.magnusson.io/contact/>Contact</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=https://www.magnusson.io/post/>Posts</a></li></ul></div></nav><main><div class=u-wrapper><div class=u-padding><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/home-manager-review/ rel=bookmark>Review of home manager</a></h2><time datetime=2020-09-17T15:14:16+02:00>17 September, 2020</time></header><div class=paragraph><p>A common theme among the people who fall in love with Nix (or its cousin
<a href=https://nixos.org/>NixOS</a>) is that they want it to manage everything for them. Finding
out the limits of that capability and where it breaks down is part of
each’s journey.</p></div><div class=paragraph><p>An obvious enough limit to Nix’s reach is secret management. It can
easily handle public keys, SSH or cryptographic ones, but the private
keys cannot be managed by its store as it is readable by all.</p></div><div class=paragraph><p>The promise of Nix is that we will never break our system by updating
it. We can always roll back to a previous working version, once we have
a working version at all. This is in contrast to, say, every other Linux
distribution. I have borked Ubuntu, Arch, Fedora and others during system
updates. Often the safest way to update the system is to back up <code>/home</code>
and reinstall the OS.</p></div><div class=paragraph><p>From somewhere comes the idea that a user on a Linux system should be able
to install their own programs and manage their own system services. (See
<a href=https://nullprogram.com/blog/2017/06/19/>Chris Wellons</a> for where you can run
with this idea to if your sysadmin gives you a C compiler.) This
seems odd from a historical perspective. In a true multi-user system, the
system administrators normally do not want users to be able to install
arbitrary software or run services. On a modern "multi"-user system,
where there is a only single user, avoiding system packages and services
seems like some kind of theater.</p></div><div class=paragraph><p>Yet we do it anyway. An argument I sometimes make to myself is that this
is a cleaner separation between what I need the system to do versus what
I do on it. I may want to be able to run traceroute as root, but I don’t
care about root being able to run the Go compiler.</p></div><div class=paragraph><p>NixOS has facilities to enforce this separation. It happily creates
users and their home directories, and can fill in some of the bits that
go there, like public SSH keys. It can install packages for specific
users, and allow them to define systemd services. It will not manage
the configuration of specific user packages (like dotfiles) without
some coercing. One can presumably create custom derivations of, say,
ZSH with all the configuration one wants, but who has the time?</p></div><div class=paragraph><p><a href=https://github.com/rycee/home-manager>Home manager</a> wants to fill this
gap and bring the power of Nix to user environment and configuration
management. It lets individual users say what packages they want
installed; what services they want run; and what configuration files
should go where. On the surface it seems like something I should love,
but after using it for a month I wrote it out of my system and now use
plain NixOS.</p></div><div class=paragraph><p>I used Home manager for three things:</p></div><div class="olist arabic"><ol class=arabic><li><p>Installing packages for my user.</p></li><li><p>Scheduling services for my user.</p></li><li><p>Installing configuration files for my software.</p></li></ol></div><div class=paragraph><p>The first one was never a big attraction. Home manager lets us define
a list of packages in <code>home.packages</code> of packages to install. If we
control the system configuration, we can acheive the same by defining
those packages in <code>users.users.$username.packages</code>.</p></div><div class=paragraph><p>If a user controls the system configuration (directly or through
a sysadmin), they can also define their own user services via
<code>systemd.user</code>. Home manager’s selling point is that it comes with a
large list of already defined services that we can enable with a boolean
flag, instead of having to write our own service configuration. This is
admittedly nice. In the end, I found that learning the idiosyncrazies
of each home manager service definition was a less useful use of my time
than learning how to define NixOS systemd services once and for all. The
latter is after all where the former end up.</p></div><div class=paragraph><p>As a long-time sufferer of dotfile management, I had high hopes for the
third point. And indeed, home manager will manage dotfiles just fine. It
can do this in two modes: it can generate a config file from various
options we fill out if someone has written a home manager module for
the program we’re trying to configure, or it can plomp a file on the
system verbatim from a source. I used the latter, as I didn’t feel like
learning a configuration language to be able to partially configure
program dotfiles was a good idea.</p></div><div class=paragraph><p>This works well, until we want to change anything in a dotfile. This
experiment with home manager coincided with a regular low point in my life
in which I try to use emacs. This comes with quite a lot of .emacs changes
as I use Lisp for the only thing it’s ever been good for; configuring
a text editor in the most complicated way imaginable. Now, the dotfiles
that home manager (or Nix) puts on our systems are read-only, so every
change would involve changing the source file and running <code>home-manager
switch</code>. This seems like unnecessarily many steps, especially after I
saw this brilliant <a href="https://news.ycombinator.com/item?id=11071754">Hacker news</a>
comment, which after a week of use is a much better solution for this problem.</p></div><div class=paragraph><p>All in all home manager is nice software. I can see it being useful for
people who either don’t control the system they run on but want to use
Nix in user mode to run their corner of it, or for those Nix users who
gamers (a well-adjusted group of humans if there ever was one) would call
"filthy casuals", that is, people who just want things to work and don’t
care very much about learning how to write enough Nix to make that happen.</p></div><div class=paragraph><p>I’m not included in those groups, as I run this system and explicitly
want to learn to use Nix in anger so I can try and fail to convince
people to run it in production at work. Home manager is fine software and if it
makes you happy, then please use it.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/use-ad-hoc-structs-for-flags/ rel=bookmark>Use ad hoc structs for command-line flags in Go</a></h2><time datetime=2020-06-29T09:15:48+02:00>29 June, 2020</time></header><div class=paragraph><p>The path of least resistance to commandline flag parsing in Go is to use the <a href=https://golang.org/pkg/flag/>flag</a> package from the standard library. A lot of times the result looks like this:</p></div><div class=listingblock><div class=content><pre class=highlight><code class=language-go data-lang=go>func main() {
  help := flags.Bool(&#34;help&#34;, false, &#34;HALP&#34;)
  frobinate := flags.Int(&#34;frobinate&#34;, 0, &#34;Amount to frobinate by&#34;)
  blargalarg := flags.String(&#34;blargalarg&#34;, &#34;&#34;, &#34;Social media comment&#34;)
  // [713 variables later]
  flag.Parse()

  // Much later
  if *blargalarg != &#34;&#34; {
    // Do things. We may or may not remember what this variable is.
  }
}</code></pre></div></div><div class=paragraph><p>That is, we have a bunch of variables lying around we don’t really care about and take up perfectly good names. If we see one of them later in the program, we don’t have any context on where it comes from, so we have to start jumping around in the source.</p></div><div class=paragraph><p>In my projects I’ve used a little accounting trick to hold these flags. I find it helps me deal with them. We just define an anonymous struct to hold the flags:</p></div><div class=listingblock><div class=content><pre class=highlight><code class=language-go data-lang=go>func main() {
  flags := struct{
    help *bool
    frobinate *int
    blargalarg *string
    // [713 field definitions]
  }{
    help: flags.Bool(&#34;help&#34;, false, &#34;HALP&#34;),
    frobinate: flags.Int(&#34;frobinate&#34;, 0, &#34;Amount to frobinate by&#34;),
    blargalarg: flags.String(&#34;blargalarg&#34;, &#34;&#34;, &#34;Social media comment&#34;),
    // [713 field instantiations]
  }
  flag.Parse()

  // Much later
  if *flags.blargalarg != &#34;&#34; {
    // AAAAAH YES IT&#39;S A FLAG
  }
}</code></pre></div></div><div class=paragraph><p>If I really need to, I can pull the anonymous struct out into its own global variable or type definition or whatever, and pass it around as arguments to functions that deal with its contents. That is not as handy with a litter of flag variables. But really I just find that defining all these flags clearly in one place makes the program easier to read later once I’ve forgotten what it does.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/kleroteria/ rel=bookmark>Kleroteria</a></h2><time datetime=2020-04-15T08:51:31+02:00>15 April, 2020</time></header><div class=paragraph><p>I got picked in
<a href=https://www.kleroteria.org/>Kleroteria</a>
a couple of months ago. This is my contribution.</p></div><hr><div class=paragraph><p>Three years ago, my wife and I moved to Amsterdam. We wanted to have kids, and
thought the Netherlands was a better place to do that than Mexico, where my wife
is from and we lived.</p></div><div class=paragraph><p>We’ve both moved around a lot, and have picked up the languages of the places
we’ve lived. That’s how we speak French and Spanish, along with English.
Learning those was always a necessity; no one in France is going to speak
English voluntarily, and my in-laws don’t speak the best English so I had to
learn Spanish.</p></div><div class=paragraph><p>So it was a change to come to the Netherlands. Everyone here speaks perfect
English. They also have no patience for your attempts at Dutch pronunciation or
verb conjugation. The second they hear you’re not from here, they switch. On
paper this is great, but it means that after three years here I still don’t
speak Dutch. I can never get anyone to have a whole conversation with me in it.</p></div><div class=paragraph><p>A couple of weeks after we came here, we got pregnant. We had a boy, who has
grown up into a little man who loves cars and trains, makes funny faces at the
dinner table, and keeps trying to show our dog his books. ("Pancho! See!", but
Pancho doesn’t care.)</p></div><div class=paragraph><p>We speak to him each in our own language, and by now he understands what we say.
He’s been going to daycare here since he was five months old, where they speak
Dutch, so he understands that as well. Kids who grow up with more than one
language start speaking later, which is can be frustrating for everyone. He
knows what he wants to say, but can’t figure out what words to use, and we have
to keep guessing at sounds while other parents don’t.</p></div><div class=paragraph><p>He’s finally speaking now. He tells us everything he wants and knows. In Dutch.
Every time. Every word comes out in Dutch. And we still don’t really speak it.
It’s not really any less frustrating for anyone. There’s a lot of guessing at
pronunciation and Google translate.</p></div><div class=paragraph><p>But what do you know. I did finally get someone to speak Dutch to me.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/bug-checklist/ rel=bookmark>Bug-fixing checklist</a></h2><time datetime=2020-04-15T07:04:37+02:00>15 April, 2020</time></header><div class=paragraph><p>It is OK not to do all of these things for a given bug. Some bugs are trivial,
or nontrivial to reproduce or write tests for. But you should explicitly decide
not to do some of these things for any given bug, and be able to explain why.</p></div><div class="olist arabic"><ol class=arabic><li><p>Is there a (possibly old, closed) issue for the bug?</p></li><li><p>Can you reproduce the bug manually?</p></li><li><p>Can you write a regression test for the bug?</p></li><li><p>Did you check that your change actually fixes the problem?</p></li><li><p>Does the fix’s commit message explain the bug, the fix, and point to the issue?</p></li></ol></div><div class=paragraph><p>It’s debatable whether checking for old or closed issues is the responsibility
of the developer fixing the bug or a project manager who triages the backlog.
Sometimes the second person doesn’t exist, but the job should still be done.</p></div><div class=paragraph><p>Remember that a bug report is a report of a symptom. A bug fix is directed at
a cause. A software symptom may have more than one cause, making bug fixes that
say "This fixes issue X" very optimistic about what they claim to achieve.</p></div><div class=paragraph><p>Exercise moderation and common sense in all things. Both 0% and 100% test
coverage are awkward places to live in. Sometimes the information or effort
needed to write a test make it too expensive to do so. However, when writing a
test is cheap and easy or can be made so without causing harm, there should be
a good reason not to do it.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/gitsplorer/ rel=bookmark>Gitsplorer</a></h2><time datetime=2019-10-20T16:49:02+02:00>20 October, 2019</time></header><div class=paragraph><p>Have you ever found yourself using Git and thinking "This is great, but I wish
these filesystem operations were read-only and ten times slower?". Well, friend,
do I have news for you.</p></div><div class=paragraph><p>API of a Golang codebase at different times in its history. To do this, I
figured I’d clone the repo, check out commit A and analyze it, then check out
commit B and analyze that, and boo! Hiss! That’s inelegant and leaves clutter
that needs to be cleaned up all around the disk. There has got to be a better
way!</p></div><div class=paragraph><p>Once I made a <a href=https://github.com/gunnihinn/git-commit-mine>Git commit hash
miner</a> because I wanted to race it against a coworker to see who could get a
commit with more leading zeros into a frequently used repository at work. That
had the side effect of teaching me some about Git’s internals, like what its
objects are (blobs, trees, commits, tags) and how they fit together. I figured
that if I could convince the Golang AST parser to read the Git database instead
of the filesystem, I could do what I wanted in a much better way.</p></div><div class=paragraph><p>Alas, doing that would have required monkey-patching the Go standard library,
and I don’t want to hunt down every system call it ends up making to be sure I
got them all. However, Git is famously a content-addressable filesystem, so what
if we just made a filesystem that points to a given commit in a repo and pointed
the parser at that?</p></div><div class=paragraph><p>This turns out to be pretty easy to do by combining <code>libgit2</code> and <code>libfuse</code>. We
use the former to read objects in the Git repository. (The objects are easy to
read by hand, until you have to read packed objects. That’s doable, but a bit
of a distraction in what is already quite the distraction.) We then use the
latter to create a very basic read-only filesystem. In the end, we have a
read-only version of <code>git checkout</code> that writes nothing to disk.</p></div><div class=paragraph><p>I put a prototype of this together in Python, because I’m lazy. It’s called
<a href=https://github.com/gunnihinn/gitsplorer/><code>gitsplorer</code></a> and you should absolutely
not use it anywhere near a production system. It scratches my itch pretty well,
though. In addition to my API comparisons (which I still haven’t got to), I do
sometimes want to poke around the state of a repository at a given commit and
this saves me doing a stash-checkout dance or reading the <code>git worktree</code> manpage
again.</p></div><div class=paragraph><p>For fun, and to see how bad of an idea this was, I came up with a very
unscientific benchmark: We checkout the Linux kernel repository at a randomly
selected
<a href=https://github.com/torvalds/linux/commit/29c7f1f53bfb3770bdb65a9e79064a963dd40621>commit</a>,
run Boyter’s <a href=https://github.com/boyter/scc>scc</a> line-counting tool, and checkout
<code>master</code> again. We do this both with <code>gitsplorer</code> and with ye olde <code>git
checkout</code>. The results speak for themselves:</p></div><div class=listingblock><div class=content><pre>git checkout: 62 seconds
gitsplorer: 567 seconds</pre></div></div><div class=paragraph><p>The <code>gitsplorer</code> version is also remarkable for spending all its time using 100%
of a CPU, which the <code>git</code> version does not. (It uses around 90% of a CPU while
doing the checkouts, then all of my CPUs while counting lines. The Python FUSE
filesystem is single-threaded, so beyond Python being slow it must also be a
point of congestion for the line counting.) I did some basic profiling of this
with the wonderful profiler <a href=https://github.com/P403n1x87/austin>Austin</a>, and saw
that the Python process spends most of its time reading Git blobs. I think, but
did not verify, that this is because <code>libgit2</code> decompresses the contents of the
blobs on every such call, while most of the reads we make are in the FUSE
<code>getattr</code> call where we are only interested in metadata about the blob. I made
no attempts to optimize any of this.</p></div><div class=paragraph><p>So, friends, if you’ve ever wished <code>git checkout</code> was read-only and 10 times
slower than it is, today is your lucky day.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/lyttle-lytton-2020/ rel=bookmark>Lyttle Lytton 2020</a></h2><time datetime=2019-10-06T11:07:55+02:00>6 October, 2019</time></header><div class=paragraph><p>My <a href=http://adamcadre.ac/lyttle.html>Lyttle Lytton</a> entry for 2020:</p></div><div class=quoteblock><blockquote><div class=paragraph><p>"Actually, you do like this," maverick CEO Eric Davies, Ph.D., insisted as he
pulled my foreskin back and cunnilingussed my pee hole.</p></div></blockquote></div><div class=paragraph><p>I’m not exactly proud of it, but I’m glad it’s no longer in my head.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/not-this-world/ rel=bookmark>Not made for this world</a></h2><time datetime=2019-07-31T07:38:25+02:00>31 July, 2019</time></header><div class=paragraph><p>It’s hot tonight, and this is going to be mostly the whiskey talking while I
wait for it to get cool enough to sleep. I’ve killed the mosquitos I’ve seen,
however, so until then I have only Haskell to keep me company.</p></div><div class=paragraph><p>This morning, tef tweeted about
<a href=https://twitter.com/tef_ebooks/status/1155705690947805184>monads</a>,
which sent the Haskell pack his way with
barks of not getting it. Just now, pinboard was reminded of some guy’s rage
against
<a href=https://twitter.com/Pinboard/status/1156288764345348096>Esperanto</a>,
from back in the 90’s when the web was fun and mostly devoted
to things like explaining how "The Downward Spiral" is a concept album or
destroying Unix instead of each other’s mental health.</p></div><div class=paragraph><p>For the Haskell pack, I did a PhD in the type of math that necessitates a lot of
category theory, and I have looked at your use of category theory, and judged it
to be unnecessary and pretentious and mainly focused on making you look smart
while being entirely trivial. But this is not that kind of blog post, one that
gets too tangled up in whether category theory is useful to get to the point.
(If nothing else,
<a href=https://jneem.github.io/merging/>Pijul</a>
proves that category theory is useful.) We’re here to discuss how Haskell as a
whole is nonsense if you’re not an academic. Our claim is that Haskell is a
useless language for writing software that has users.</p></div><div class=paragraph><p>Our point is simple, and focused on IO. We propose that you can measure how
user-facing a program or language is by measuring how much of its time it spends
or worries about doing IO. That is, after all, the medium through which anyone
who is not a program’s author (of which there may be many) will interact with
the program. The time spent doing IO can be on the command line, via a GUI, over
a network, or wherever; but to be a serious contender for user-facing programs,
a language has to make IO be easy.</p></div><div class=paragraph><p>C is a terrible language for most new things today. Anyone writing new software
in C, that they expect to be used by other than thouroughly vetted people, needs
to be able to explain why they’ve chosen C. At the same time, a lot of us are
still exposed to C through the BSD or Linux kernels and syscalls, the undying
popularity of K&amp;R, random software on the internet, or other vectors. The
culture around C invented the modern language textbook, K&amp;R, and the modern
user-facing program, "Hello world", both of which spend most or all of their
time dealing with IO to talk to you or other users.</p></div><div class=paragraph><p>I claim making IO as simple as possible, which C does for all its faults, to do
is analogous to trying to making it as simple as possible for other people to
talk to you in designed languages as you can.<sup class=footnote>[<a id=_footnoteref_1 class=footnote href=#_footnotedef_1 title="View footnote.">1</a>]</sup>. Esperanto shows you can fail
at that goal, if you even had it, for it favors sounds native to European
languages above others. Likewise, Haskell shows you can fail at the goal of
making IO easy, if you even had it, for it does not.</p></div><div class=paragraph><p>Haskell is a purely functional, lazily evaluated language, with a type system.
Like tef explains, that is great, until you run into IO. Up until that point,
you could rearrange computations in any order you liked, if they needed to be
done at all. As soon as you need to do IO, though, you need something to happen
before another thing, which makes you very unhappy if you’re Haskell. It in fact
makes you so unhappy that you’ll drag the entire lost-at-sea community of
category theorists into the orbit of your language just so you can have an
abstraction for doing IO that fits into your model of the world. This
abstraction, monoids, then comes with the added benefit of being abstract enough
that all of your programmers can spend their time explaining it to each other
instead of writing programs that use the abstraction to do IO, and therefore
deal with any actual users.</p></div><div class=paragraph><p>Haskell is where programmers go to not have users.</p></div><div id=footnotes><hr><div class=footnote id=_footnotedef_1><a href=#_footnoteref_1>1</a>. One could say that what I mean is something more like making FFI as easy as possible, but that’s missing the point and would just move this discussion to some other, less inflammatory, level that we’re keen to avoid.</div></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/curvature/ rel=bookmark>Curvature as a bilinear form</a></h2><time datetime=2019-05-15T07:36:52+02:00>15 May, 2019</time></header><div class=paragraph><p>Here’s something I thought of when I couldn’t sleep last night.</p></div><div class=paragraph><p>The curvature tensor of a Kähler metric can be viewed as a Hermitian form on
\(\bigwedge^{1,1} T_X^*\) by mapping \(\operatorname{End} T_X \to \bigwedge^{1,1}
T_X^*\) via the metric.</p></div><div class=paragraph><p>If we’re on a compact Kähler manifold with zero first Chern class, then for each
Kähler class \(\omega\) and \((1,1)\)-classes \(u, v\), we can pick the Ricci-flat
metric in \(\omega\) and the harmonic representatives of \(u, v\). If \(R\) is the
curvature tensor of the metric, viewed as a Hermitian form, we can then set
\[
b(u,v)(\omega) := \int_X R(u, v) \, dV_{\omega}.
\]
This defines a smooth bilinear form \(b\) on the tangent space of the Kähler cone
of \(X\).</p></div><div class=paragraph><p>Besides being fun times, can we say anything interesting about \(b\)? For example,
what is its norm with respect to the Riemannian metric on the Kähler cone, or
its trace with respect to that metric? Can we integrate it over some subset of
the cone?</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/choices/ rel=bookmark>Choices</a></h2><time datetime=2019-03-09T07:32:23+02:00>9 March, 2019</time></header><div class=paragraph><p>I only have time to work on the arXiv project so often, so I’m taking a lot of
time between sessions to think about what I’m doing. When I look at my system
design notes, I feel like all the decisions I’m making are the obvious choices,
but they also were not at all obvious when I started thinking about them. It’s a
good feeling.</p></div></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=https://www.magnusson.io/post/queuesim/ rel=bookmark>Queuesim</a></h2><time datetime=2019-03-08T07:33:20+02:00>8 March, 2019</time></header><div class=paragraph><p>I haven’t made a lot of progress on my projects. I <em>did</em> create a Scaleway VM
and shoved an OAI harvester on there that’s happily downloading the arXiv’s
backlog of metadata. I can also parse the XML it fetches, and have some ideas
about how I’m going to store it.</p></div><div class=paragraph><p>This lack of progress mostly comes from me being nerd-sniped into thinking
about bounded queues under load. My
<a href=https://github.com/bookingcom/carbonapi/issues/35>old work project</a>
wanted to use a FIFO queue to hold its requests. That is a bad idea, because
FIFO queues perform very poorly under load, as I
<a href=https://github.com/gunnihinn/queuesim>went a little overboard</a>
in demonstrating.</p></div><div class=paragraph><p>Funnily enough, that very simple thing is one of my most popular Github
projects ever.</p></div></article><nav><a class="Pagination u-clickable" href=https://www.magnusson.io/page/3/ rel=prev>« Previous</a>
<a class="Pagination Pagination--right u-clickable" href=https://www.magnusson.io/ rel=next>Next »</a></nav></div></div></main><footer class=Footer><div class=u-wrapper><div class=u-padding>Copyright :: Gunnar Þór Magnússon</div></div><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></footer></body></html>